package com.parkwoocheol.kmpdatastore.ksp.generators

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSPropertyDeclaration
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.TypeSpec

/**
 * Generates validator classes for classes with validation annotations.
 *
 * For a class like:
 * ```kotlin
 * data class User(
 *     @NotBlank val name: String,
 *     @Min(0) @Max(150) val age: Int,
 *     @Pattern("[a-z]+@[a-z]+\\.[a-z]+") val email: String
 * )
 * ```
 *
 * Generates:
 * - `UserValidator` object with `validate(user: User): ValidationResult` method
 */
class ValidationGenerator(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
) {
    companion object {
        private val VALIDATION_RESULT =
            ClassName(
                "com.parkwoocheol.kmpdatastore.annotations.runtime",
                "ValidationResult",
            )
    }

    fun generate(classDecl: KSClassDeclaration) {
        val className = classDecl.simpleName.asString()
        val packageName = classDecl.packageName.asString()
        val validatorClassName = "${className}Validator"

        // Collect validation constraints from properties
        val validations =
            classDecl.getAllProperties().mapNotNull { prop ->
                collectConstraints(prop)
            }.filter { it.constraints.isNotEmpty() }.toList()

        if (validations.isEmpty()) {
            logger.info("No validation constraints found for $className, skipping")
            return
        }

        // Generate validator object
        val validatorSpec =
            TypeSpec.objectBuilder(validatorClassName)
                .addKdoc(
                    """
                    Generated validator for [$className].
                    
                    Validates the following constraints:
                    ${validations.flatMap {
                            v ->
                        v.constraints.map { "- ${v.propertyName}: ${it.description.replace("%", "%%")}" }
                    }.joinToString("\n")}
                    """.trimIndent(),
                )
                .addFunction(generateValidateFunction(className, packageName, validations))
                .build()

        // Build the file
        val fileSpec =
            FileSpec.builder(packageName, validatorClassName)
                .addType(validatorSpec)
                .addImport("com.parkwoocheol.kmpdatastore.annotations.runtime", "ValidationResult")
                .addFileComment(
                    """
                    Generated by KMP DataStore KSP Processor.
                    Do not modify this file manually.
                    """.trimIndent(),
                )
                .build()

        // Write the file
        val file =
            codeGenerator.createNewFile(
                Dependencies(false, classDecl.containingFile!!),
                packageName,
                validatorClassName,
            )

        file.writer().use { writer ->
            fileSpec.writeTo(writer)
        }

        logger.info("Generated $validatorClassName for $className with ${validations.count()} validated properties")
    }

    private fun collectConstraints(prop: KSPropertyDeclaration): PropertyValidation? {
        val propName = prop.simpleName.asString()
        val constraints = mutableListOf<Constraint>()

        prop.annotations.forEach { annotation ->
            when (annotation.shortName.asString()) {
                "Min" -> {
                    val value = annotation.arguments.firstOrNull()?.value as? Long ?: 0L
                    constraints.add(Constraint.Min(value))
                }
                "Max" -> {
                    val value = annotation.arguments.firstOrNull()?.value as? Long ?: Long.MAX_VALUE
                    constraints.add(Constraint.Max(value))
                }
                "Pattern" -> {
                    val regex = annotation.arguments.firstOrNull()?.value as? String ?: ""
                    if (regex.isNotEmpty()) {
                        constraints.add(Constraint.Pattern(regex))
                    }
                }
                "NotBlank" -> {
                    constraints.add(Constraint.NotBlank)
                }
            }
        }

        return if (constraints.isNotEmpty()) {
            PropertyValidation(propName, constraints)
        } else {
            null
        }
    }

    private fun generateValidateFunction(
        className: String,
        packageName: String,
        validations: List<PropertyValidation>,
    ): FunSpec {
        val codeBuilder = CodeBlock.builder()
        codeBuilder.addStatement("val errors = mutableListOf<String>()")
        codeBuilder.add("\n")

        validations.forEach { (propName, constraints) ->
            constraints.forEach { constraint ->
                when (constraint) {
                    is Constraint.Min -> {
                        codeBuilder.addStatement(
                            """
                            if (obj.$propName < ${constraint.value}) {
                                errors.add("$propName must be at least ${constraint.value}")
                            }
                            """.trimIndent(),
                        )
                    }
                    is Constraint.Max -> {
                        codeBuilder.addStatement(
                            """
                            if (obj.$propName > ${constraint.value}) {
                                errors.add("$propName must be at most ${constraint.value}")
                            }
                            """.trimIndent(),
                        )
                    }
                    is Constraint.Pattern -> {
                        val msgRegex = constraint.regex.replace("\\", "\\\\").replace("\"", "\\\"").replace("%", "%%")
                        codeBuilder.addStatement(
                            """
                            if (!Regex(%S).matches(obj.$propName.toString())) {
                                errors.add("$propName must match pattern: $msgRegex")
                            }
                            """.trimIndent(),
                            constraint.regex,
                        )
                    }
                    is Constraint.NotBlank -> {
                        codeBuilder.addStatement(
                            """
                            if (obj.$propName.toString().isBlank()) {
                                errors.add("$propName must not be blank")
                            }
                            """.trimIndent(),
                        )
                    }
                }
                codeBuilder.add("\n")
            }
        }

        codeBuilder.addStatement(
            """
            return if (errors.isEmpty()) {
                ValidationResult.success()
            } else {
                ValidationResult.errors(errors)
            }
            """.trimIndent(),
        )

        return FunSpec.builder("validate")
            .addParameter("obj", ClassName(packageName, className))
            .returns(VALIDATION_RESULT)
            .addCode(codeBuilder.build())
            .addKdoc(
                """
                Validates the given [$className] instance.
                
                @param obj The object to validate
                @return [ValidationResult.Success] if valid, or [ValidationResult.Errors] with error messages
                """.trimIndent(),
            )
            .build()
    }

    sealed class Constraint {
        abstract val description: String

        data class Min(val value: Long) : Constraint() {
            override val description = "minimum value $value"
        }

        data class Max(val value: Long) : Constraint() {
            override val description = "maximum value $value"
        }

        data class Pattern(val regex: String) : Constraint() {
            override val description = "pattern $regex"
        }

        data object NotBlank : Constraint() {
            override val description = "not blank"
        }
    }

    data class PropertyValidation(
        val propertyName: String,
        val constraints: List<Constraint>,
    )
}
